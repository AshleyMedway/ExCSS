<#@ template language="C#v3.5" hostspecific="True" #>
<#@ Output Extension=".log" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Data.Linq" #>
<#@ assembly name="Microsoft.VisualStudio.Shell.Interop.8.0" #>
<#@ assembly name="EnvDTE" #>
<#@ assembly name="EnvDTE80" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #><#@ import namespace="System" #>
<#@ import namespace="System.CodeDom" #>
<#@ import namespace="System.CodeDom.Compiler" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Data.Linq" #>
<#@ import namespace="System.Data.Linq.Mapping" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #>
<#@ import namespace="Microsoft.VisualStudio.Shell.Interop" #>

<#@ import namespace="EnvDTE" #>
<#@ import namespace="EnvDTE80" #>


T4.CSS Log
---------------
<#
var currentDirectory = Path.GetDirectoryName(Host.TemplateFile);
var testFiles = Directory.GetFiles(currentDirectory, "*.csstest");
#>

Creating Tests:

<# foreach(var testFile in testFiles) { #>
  * <#= testFile #> 
<# }

var manager = Manager.Create(Host, GenerationEnvironment);
System.IO.Directory.SetCurrentDirectory(currentDirectory);

foreach(var testFile in testFiles) 
{
	var testFixtureFile = GetUnitTestFileName(testFile);
	var testFixtureName = testFixtureFile.Replace(".cs", "");
	manager.StartNewFile(testFixtureFile.Replace(".cs", ".generated.cs"));

	var lines = File.ReadAllLines(testFile);
	
#>
using NUnit.Framework;

namespace ExCSS.Tests
{
	[TestFixture]
    public partial class <#=testFixtureName#>
    { 
<#

	foreach(var line in lines)
    {
		var parts = line.Split(':');
        var attribute = parts[0];
		var attributeName = attribute.Replace("-", "_");
        var terms = parts[1].Split(';');

		foreach(var term in terms)
		{
			var trimmedTerm = term.Trim();
			var termMethodName = trimmedTerm.Replace(" ", "_").Replace("(", "").Replace(")", "").Replace("'", "").Replace("\"", "Quote")
				.Replace("/", "").Replace(".", "").Replace("#", "").Replace("-", "_").Replace(",", "_").Replace("%", "Percent");

			var termParts = trimmedTerm.Replace(",", " ").Split(' ');
			var termstring = "\"" + string.Join("\",\"", termParts) +  "\"" ;
#>
		[Test]
		public void <#=attributeName#>_<#=termMethodName#>()
		{
			var termParts = new[]{<#=termString#>}; 
			var parser = new StylesheetParser();
			var style = parser.Parse("*{<#=attribute#>: <#=trimmedTerm#> }");
			var expression = style.RuleSets[0].Declarations[0].Expression;

			Assert.AreEqual(termParts.Length, expression.Terms.Count);
<#
			for(var i = 0; i < termParts.Length; i++)
			{
				var termToCompare = termParts[i];
#>
			Assert.AreEqual("<#=termToCompare#>", expression.Terms[<#=i#>].ToString());
<#
			}
#>
		}
<#		
		}
	}
	
#>
	}
}
<#

	manager.EndBlock();
}

manager.Process(true);


#>

<#+


void WriteUnitTestHeader(string attribute)
{
	Write("");
	
}

/*
    Manager.tt from Damien Guard: http://damieng.com/blog/2009/11/06/multiple-outputs-from-t4-made-easy-revisited
*/

// Manager class records the various blocks so it can split them up
class Manager
{
    private class Block
    {
        public string Name;
        public int Start, Length;
    }

    private Block currentBlock;
    private List<Block> files = new List<Block>();
    private Block footer = new Block();
    private Block header = new Block();
    private ITextTemplatingEngineHost host;
    private StringBuilder template;
    protected List<String> generatedFileNames = new List<String>();

    public static Manager Create(ITextTemplatingEngineHost host, StringBuilder template)
    {
        return (host is IServiceProvider) ? new VSManager(host, template) : new Manager(host, template);
    }

    public void StartNewFile(string name)
    {
        if(name == null)
            throw new ArgumentNullException("name");
        CurrentBlock = new Block { Name = name };
    }

    public void StartFooter()
    {
        CurrentBlock = footer;
    }

    public void StartHeader()
    {
        CurrentBlock = header;
    }

    public void EndBlock()
    {
        if(CurrentBlock == null)
            return;
        CurrentBlock.Length = template.Length - CurrentBlock.Start;
        if(CurrentBlock != header && CurrentBlock != footer)
            files.Add(CurrentBlock);
        currentBlock = null;
    }

    public virtual void Process(bool split)
    {
        if(split)
        {
            EndBlock();
            string headerText = template.ToString(header.Start, header.Length);
            string footerText = template.ToString(footer.Start, footer.Length);
            string outputPath = Path.GetDirectoryName(host.TemplateFile);
            files.Reverse();
            foreach(Block block in files)
            {
                string fileName = Path.Combine(outputPath, block.Name);
                string content = headerText + template.ToString(block.Start, block.Length) + footerText;
                generatedFileNames.Add(fileName);
                CreateFile(fileName, content);
                template.Remove(block.Start, block.Length);
            }
        }
    }

    protected virtual void CreateFile(string fileName, string content)
    {
        if(IsFileContentDifferent(fileName, content))
            File.WriteAllText(fileName, content);
    }

    public virtual string GetCustomToolNamespace(string fileName)
    {
        return null;
    }

    public virtual string DefaultProjectNamespace
    {
        get { return null; }
    }

    protected bool IsFileContentDifferent(string fileName, string newContent)
    {
        return !(File.Exists(fileName) && File.ReadAllText(fileName) == newContent);
    }

    private Manager(ITextTemplatingEngineHost host, StringBuilder template)
    {
        this.host = host;
        this.template = template;
    }

    private Block CurrentBlock
    {
        get { return currentBlock; }
        set
        {
            if(CurrentBlock != null)
                EndBlock();
            if(value != null)
                value.Start = template.Length;
            currentBlock = value;
        }
    }

    private class VSManager : Manager
    {
        private EnvDTE.ProjectItem templateProjectItem;
        private EnvDTE.DTE dte;
        private Action<String> checkOutAction;
        private Action<IEnumerable<String>> projectSyncAction;

        public override string DefaultProjectNamespace
        {
            get
            {
                return templateProjectItem.ContainingProject.Properties.Item("DefaultNamespace").Value.ToString();
            }
        }

        public override string GetCustomToolNamespace(string fileName)
        {
            return dte.Solution.FindProjectItem(fileName).Properties.Item("CustomToolNamespace").Value.ToString();
        }

        public override void Process(bool split)
        {
            if(templateProjectItem.ProjectItems == null)
                return;
            base.Process(split);
            projectSyncAction.EndInvoke(projectSyncAction.BeginInvoke(generatedFileNames, null, null));
        }
		
        protected override void CreateFile(string fileName, string content)
        {
            if(IsFileContentDifferent(fileName, content))
            {
                CheckoutFileIfRequired(fileName);
                File.WriteAllText(fileName, content);
            }
        }

        internal VSManager(ITextTemplatingEngineHost host, StringBuilder template)
            : base(host, template)
        {
            var hostServiceProvider = (IServiceProvider)host;
            if(hostServiceProvider == null)
                throw new ArgumentNullException("Could not obtain IServiceProvider");
            dte = (EnvDTE.DTE)hostServiceProvider.GetService(typeof(EnvDTE.DTE));
            if(dte == null)
                throw new ArgumentNullException("Could not obtain DTE from host");
            templateProjectItem = dte.Solution.FindProjectItem(host.TemplateFile);
            checkOutAction = (string fileName) => dte.SourceControl.CheckOutItem(fileName);
            projectSyncAction = (IEnumerable<String> keepFileNames) => ProjectSync(templateProjectItem, keepFileNames);
        }

        private static void ProjectSync(EnvDTE.ProjectItem templateProjectItem, IEnumerable<String> keepFileNames)
        {
            var keepFileNameSet = new HashSet<String>(keepFileNames);
            var projectFiles = new Dictionary<String, EnvDTE.ProjectItem>();
            var originalFilePrefix = Path.GetFileNameWithoutExtension(templateProjectItem.get_FileNames(0)) + ".";
            foreach(EnvDTE.ProjectItem projectItem in templateProjectItem.ProjectItems)
                projectFiles.Add(projectItem.get_FileNames(0), projectItem);

            // Remove unused items from the project
            foreach(var pair in projectFiles)
                if(!keepFileNames.Contains(pair.Key) && !(Path.GetFileNameWithoutExtension(pair.Key) + ".").StartsWith(originalFilePrefix))
                    pair.Value.Delete();

            // Add missing files to the project
            foreach(string fileName in keepFileNameSet)
                if(!projectFiles.ContainsKey(fileName))
                    templateProjectItem.ProjectItems.AddFromFile(fileName);
        }

        private void CheckoutFileIfRequired(string fileName)
        {
            var sc = dte.SourceControl;
            if(sc != null && sc.IsItemUnderSCC(fileName) && !sc.IsItemCheckedOut(fileName))
                checkOutAction.EndInvoke(checkOutAction.BeginInvoke(fileName, null, null));
        }
    }
}
/*
    End of Manager.tt
*/

public string GetUnitTestFileName(string testFileName) {
	return Path.GetFileNameWithoutExtension(testFileName.Replace(".csstest","")) + ".cs";
}
#>